/*
 * generated by Xtext 2.10.0
 */
package codeskills.designer.game.status.serializer;

import codeskills.designer.game.status.services.StatusGrammarAccess;
import codeskills.designer.game.status.status.AchievementS;
import codeskills.designer.game.status.status.GameS;
import codeskills.designer.game.status.status.GroupS;
import codeskills.designer.game.status.status.LevelS;
import codeskills.designer.game.status.status.Status;
import codeskills.designer.game.status.status.StatusPackage;
import codeskills.designer.game.status.status.TaskS;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class StatusSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private StatusGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StatusPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatusPackage.ACHIEVEMENT_S:
				sequence_AchievementS(context, (AchievementS) semanticObject); 
				return; 
			case StatusPackage.GAME_S:
				sequence_GameS(context, (GameS) semanticObject); 
				return; 
			case StatusPackage.GROUP_S:
				sequence_GroupS(context, (GroupS) semanticObject); 
				return; 
			case StatusPackage.LEVEL_S:
				sequence_LevelS(context, (LevelS) semanticObject); 
				return; 
			case StatusPackage.STATUS:
				sequence_Status(context, (Status) semanticObject); 
				return; 
			case StatusPackage.TASK_S:
				sequence_TaskS(context, (TaskS) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     S returns AchievementS
	 *     AchievementS returns AchievementS
	 *
	 * Constraint:
	 *     (achievement=[Achievement|ID] status=Status tasks+=TaskS tasks+=TaskS*)
	 */
	protected void sequence_AchievementS(ISerializationContext context, AchievementS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     S returns GameS
	 *     GameS returns GameS
	 *
	 * Constraint:
	 *     (
	 *         levels+=LevelS 
	 *         levels+=LevelS* 
	 *         signature=STRING 
	 *         created=LONG 
	 *         status=Status 
	 *         currentScore=INT
	 *     )
	 */
	protected void sequence_GameS(ISerializationContext context, GameS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     S returns GroupS
	 *     GroupS returns GroupS
	 *
	 * Constraint:
	 *     (group=[Group|ID] status=Status achievements+=AchievementS achievements+=AchievementS*)
	 */
	protected void sequence_GroupS(ISerializationContext context, GroupS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     S returns LevelS
	 *     LevelS returns LevelS
	 *
	 * Constraint:
	 *     (level=[Level|ID] status=Status isCurrent?=BOOL? groups+=GroupS groups+=GroupS*)
	 */
	protected void sequence_LevelS(ISerializationContext context, LevelS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Status returns Status
	 *
	 * Constraint:
	 *     (complete?=BOOL milliseconds=LONG)
	 */
	protected void sequence_Status(ISerializationContext context, Status semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatusPackage.Literals.STATUS__COMPLETE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatusPackage.Literals.STATUS__COMPLETE));
			if (transientValues.isValueTransient(semanticObject, StatusPackage.Literals.STATUS__MILLISECONDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatusPackage.Literals.STATUS__MILLISECONDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatusAccess().getCompleteBOOLTerminalRuleCall_3_0(), semanticObject.isComplete());
		feeder.accept(grammarAccess.getStatusAccess().getMillisecondsLONGTerminalRuleCall_7_0(), semanticObject.getMilliseconds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     S returns TaskS
	 *     TaskS returns TaskS
	 *
	 * Constraint:
	 *     (task=[Task|ID] status=Status)
	 */
	protected void sequence_TaskS(ISerializationContext context, TaskS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatusPackage.Literals.TASK_S__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatusPackage.Literals.TASK_S__TASK));
			if (transientValues.isValueTransient(semanticObject, StatusPackage.Literals.S__STATUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatusPackage.Literals.S__STATUS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskSAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.getTask());
		feeder.accept(grammarAccess.getTaskSAccess().getStatusStatusParserRuleCall_2_0(), semanticObject.getStatus());
		feeder.finish();
	}
	
	
}
